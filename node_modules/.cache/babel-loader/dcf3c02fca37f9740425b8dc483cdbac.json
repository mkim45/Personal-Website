{"ast":null,"code":"'use strict';\n/*\n  node-schedule\n  A cron-like and not-cron-like job scheduler for Node.\n*/\n\nvar _require = require('./Job'),\n    Job = _require.Job,\n    scheduledJobs = _require.scheduledJobs;\n/* API\n  invoke()\n  runOnDate(date)\n  schedule(date || recurrenceRule || cronstring)\n  cancel(reschedule = false)\n  cancelNext(reschedule = true)\n\n   Property constraints\n  name: readonly\n  job: readwrite\n*/\n\n/* Convenience methods */\n\n\nfunction scheduleJob() {\n  if (arguments.length < 2) {\n    throw new RangeError('Invalid number of arguments');\n  }\n\n  var name = arguments.length >= 3 && typeof arguments[0] === 'string' ? arguments[0] : null;\n  var spec = name ? arguments[1] : arguments[0];\n  var method = name ? arguments[2] : arguments[1];\n  var callback = name ? arguments[3] : arguments[2];\n\n  if (typeof method !== 'function') {\n    throw new RangeError('The job method must be a function.');\n  }\n\n  var job = new Job(name, method, callback);\n\n  if (job.schedule(spec)) {\n    return job;\n  }\n\n  return null;\n}\n\nfunction rescheduleJob(job, spec) {\n  if (job instanceof Job) {\n    if (job.reschedule(spec)) {\n      return job;\n    }\n  } else if (typeof job === 'string') {\n    if (Object.prototype.hasOwnProperty.call(scheduledJobs, job)) {\n      if (scheduledJobs[job].reschedule(spec)) {\n        return scheduledJobs[job];\n      }\n    } else {\n      throw new Error('Cannot reschedule one-off job by name, pass job reference instead');\n    }\n  }\n\n  return null;\n}\n\nfunction cancelJob(job) {\n  var success = false;\n\n  if (job instanceof Job) {\n    success = job.cancel();\n  } else if (typeof job == 'string' || job instanceof String) {\n    if (job in scheduledJobs && Object.prototype.hasOwnProperty.call(scheduledJobs, job)) {\n      success = scheduledJobs[job].cancel();\n    }\n  }\n\n  return success;\n}\n\nfunction gracefulShutdown() {\n  var jobs = Object.keys(scheduledJobs).map(function (key) {\n    return scheduledJobs[key];\n  });\n  jobs.forEach(function (job) {\n    job.cancel();\n  });\n  var running = false;\n\n  for (var i = 0; i < jobs.length; i++) {\n    if (jobs[i].running > 0) {\n      running = true;\n      break;\n    }\n  }\n\n  return new Promise(function (resolve) {\n    if (running) {\n      setInterval(function () {\n        for (var _i = 0; _i < jobs.length; _i++) {\n          if (jobs[_i].running > 0) {\n            return;\n          }\n        }\n\n        resolve();\n      }, 500);\n    } else {\n      resolve();\n    }\n  });\n}\n/* Public API */\n\n\nmodule.exports = {\n  scheduleJob: scheduleJob,\n  rescheduleJob: rescheduleJob,\n  scheduledJobs: scheduledJobs,\n  cancelJob: cancelJob,\n  gracefulShutdown: gracefulShutdown\n};","map":null,"metadata":{},"sourceType":"script"}