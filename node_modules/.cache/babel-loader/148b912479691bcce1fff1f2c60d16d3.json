{"ast":null,"code":"'use strict';\n\nvar lt = require('long-timeout');\n\nvar CronDate = require('cron-parser/lib/date');\n\nvar sorted = require('sorted-array-functions');\n\nvar invocations = [];\nvar currentInvocation = null;\n/* DoesntRecur rule */\n\nvar DoesntRecur = new RecurrenceRule();\nDoesntRecur.recurs = false;\n/* Invocation object */\n\nfunction Invocation(job, fireDate, recurrenceRule, endDate) {\n  this.job = job;\n  this.fireDate = fireDate;\n  this.endDate = endDate;\n  this.recurrenceRule = recurrenceRule || DoesntRecur;\n  this.timerID = null;\n}\n\nfunction sorter(a, b) {\n  return a.fireDate.getTime() - b.fireDate.getTime();\n}\n/* Range object */\n\n\nfunction Range(start, end, step) {\n  this.start = start || 0;\n  this.end = end || 60;\n  this.step = step || 1;\n}\n\nRange.prototype.contains = function (val) {\n  if (this.step === null || this.step === 1) {\n    return val >= this.start && val <= this.end;\n  } else {\n    for (var i = this.start; i < this.end; i += this.step) {\n      if (i === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n/* RecurrenceRule object */\n\n/*\n  Interpreting each property:\n  null - any value is valid\n  number - fixed value\n  Range - value must fall in range\n  array - value must validate against any item in list\n\n  NOTE: Cron months are 1-based, but RecurrenceRule months are 0-based.\n*/\n\n\nfunction RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {\n  this.recurs = true;\n  this.year = year == null ? null : year;\n  this.month = month == null ? null : month;\n  this.date = date == null ? null : date;\n  this.dayOfWeek = dayOfWeek == null ? null : dayOfWeek;\n  this.hour = hour == null ? null : hour;\n  this.minute = minute == null ? null : minute;\n  this.second = second == null ? 0 : second;\n}\n\nRecurrenceRule.prototype.isValid = function () {\n  function isValidType(num) {\n    if (Array.isArray(num) || num instanceof Array) {\n      return num.every(function (e) {\n        return isValidType(e);\n      });\n    }\n\n    return !(Number.isNaN(Number(num)) && !(num instanceof Range));\n  }\n\n  if (this.month !== null && (this.month < 0 || this.month > 11 || !isValidType(this.month))) {\n    return false;\n  }\n\n  if (this.dayOfWeek !== null && (this.dayOfWeek < 0 || this.dayOfWeek > 6 || !isValidType(this.dayOfWeek))) {\n    return false;\n  }\n\n  if (this.hour !== null && (this.hour < 0 || this.hour > 23 || !isValidType(this.hour))) {\n    return false;\n  }\n\n  if (this.minute !== null && (this.minute < 0 || this.minute > 59 || !isValidType(this.minute))) {\n    return false;\n  }\n\n  if (this.second !== null && (this.second < 0 || this.second > 59 || !isValidType(this.second))) {\n    return false;\n  }\n\n  if (this.date !== null) {\n    if (!isValidType(this.date)) {\n      return false;\n    }\n\n    switch (this.month) {\n      case 3:\n      case 5:\n      case 8:\n      case 10:\n        if (this.date < 1 || this.date > 30) {\n          return false;\n        }\n\n        break;\n\n      case 1:\n        if (this.date < 1 || this.date > 29) {\n          return false;\n        }\n\n        break;\n\n      default:\n        if (this.date < 1 || this.date > 31) {\n          return false;\n        }\n\n    }\n  }\n\n  return true;\n};\n\nRecurrenceRule.prototype.nextInvocationDate = function (base) {\n  var next = this._nextInvocationDate(base);\n\n  return next ? next.toDate() : null;\n};\n\nRecurrenceRule.prototype._nextInvocationDate = function (base) {\n  base = base instanceof CronDate || base instanceof Date ? base : new Date();\n\n  if (!this.recurs) {\n    return null;\n  }\n\n  if (!this.isValid()) {\n    return null;\n  }\n\n  var now = new CronDate(Date.now(), this.tz);\n  var fullYear = now.getFullYear();\n\n  if (this.year !== null && typeof this.year == 'number' && this.year < fullYear) {\n    return null;\n  }\n\n  var next = new CronDate(base.getTime(), this.tz);\n  next.addSecond();\n\n  while (true) {\n    if (this.year !== null) {\n      fullYear = next.getFullYear();\n\n      if (typeof this.year == 'number' && this.year < fullYear) {\n        next = null;\n        break;\n      }\n\n      if (!recurMatch(fullYear, this.year)) {\n        next.addYear();\n        next.setMonth(0);\n        next.setDate(1);\n        next.setHours(0);\n        next.setMinutes(0);\n        next.setSeconds(0);\n        continue;\n      }\n    }\n\n    if (this.month != null && !recurMatch(next.getMonth(), this.month)) {\n      next.addMonth();\n      continue;\n    }\n\n    if (this.date != null && !recurMatch(next.getDate(), this.date)) {\n      next.addDay();\n      continue;\n    }\n\n    if (this.dayOfWeek != null && !recurMatch(next.getDay(), this.dayOfWeek)) {\n      next.addDay();\n      continue;\n    }\n\n    if (this.hour != null && !recurMatch(next.getHours(), this.hour)) {\n      next.addHour();\n      continue;\n    }\n\n    if (this.minute != null && !recurMatch(next.getMinutes(), this.minute)) {\n      next.addMinute();\n      continue;\n    }\n\n    if (this.second != null && !recurMatch(next.getSeconds(), this.second)) {\n      next.addSecond();\n      continue;\n    }\n\n    break;\n  }\n\n  return next;\n};\n\nfunction recurMatch(val, matcher) {\n  if (matcher == null) {\n    return true;\n  }\n\n  if (typeof matcher === 'number') {\n    return val === matcher;\n  } else if (typeof matcher === 'string') {\n    return val === Number(matcher);\n  } else if (matcher instanceof Range) {\n    return matcher.contains(val);\n  } else if (Array.isArray(matcher) || matcher instanceof Array) {\n    for (var i = 0; i < matcher.length; i++) {\n      if (recurMatch(val, matcher[i])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/* Date-based scheduler */\n\n\nfunction runOnDate(date, job) {\n  var now = Date.now();\n  var then = date.getTime();\n  return lt.setTimeout(function () {\n    if (then > Date.now()) runOnDate(date, job);else job();\n  }, then < now ? 0 : then - now);\n}\n\nfunction scheduleInvocation(invocation) {\n  sorted.add(invocations, invocation, sorter);\n  prepareNextInvocation();\n  var date = invocation.fireDate instanceof CronDate ? invocation.fireDate.toDate() : invocation.fireDate;\n  invocation.job.emit('scheduled', date);\n}\n\nfunction prepareNextInvocation() {\n  if (invocations.length > 0 && currentInvocation !== invocations[0]) {\n    if (currentInvocation !== null) {\n      lt.clearTimeout(currentInvocation.timerID);\n      currentInvocation.timerID = null;\n      currentInvocation = null;\n    }\n\n    currentInvocation = invocations[0];\n    var job = currentInvocation.job;\n    var cinv = currentInvocation;\n    currentInvocation.timerID = runOnDate(currentInvocation.fireDate, function () {\n      currentInvocationFinished();\n\n      if (job.callback) {\n        job.callback();\n      }\n\n      if (cinv.recurrenceRule.recurs || cinv.recurrenceRule._endDate === null) {\n        var inv = scheduleNextRecurrence(cinv.recurrenceRule, cinv.job, cinv.fireDate, cinv.endDate);\n\n        if (inv !== null) {\n          inv.job.trackInvocation(inv);\n        }\n      }\n\n      job.stopTrackingInvocation(cinv);\n\n      try {\n        var result = job.invoke(cinv.fireDate instanceof CronDate ? cinv.fireDate.toDate() : cinv.fireDate);\n        job.emit('run');\n        job.running += 1;\n\n        if (result instanceof Promise) {\n          result.then(function (value) {\n            job.emit('success', value);\n            job.running -= 1;\n          }).catch(function (err) {\n            job.emit('error', err);\n            job.running -= 1;\n          });\n        } else {\n          job.emit('success', result);\n          job.running -= 1;\n        }\n      } catch (err) {\n        job.emit('error', err);\n        job.running -= 1;\n      }\n\n      if (job.isOneTimeJob) {\n        job.deleteFromSchedule();\n      }\n    });\n  }\n}\n\nfunction currentInvocationFinished() {\n  invocations.shift();\n  currentInvocation = null;\n  prepareNextInvocation();\n}\n\nfunction cancelInvocation(invocation) {\n  var idx = invocations.indexOf(invocation);\n\n  if (idx > -1) {\n    invocations.splice(idx, 1);\n\n    if (invocation.timerID !== null) {\n      lt.clearTimeout(invocation.timerID);\n    }\n\n    if (currentInvocation === invocation) {\n      currentInvocation = null;\n    }\n\n    invocation.job.emit('canceled', invocation.fireDate);\n    prepareNextInvocation();\n  }\n}\n/* Recurrence scheduler */\n\n\nfunction scheduleNextRecurrence(rule, job, prevDate, endDate) {\n  prevDate = prevDate instanceof CronDate ? prevDate : new CronDate();\n  var date = rule instanceof RecurrenceRule ? rule._nextInvocationDate(prevDate) : rule.next();\n\n  if (date === null) {\n    return null;\n  }\n\n  if (endDate instanceof CronDate && date.getTime() > endDate.getTime()) {\n    return null;\n  }\n\n  var inv = new Invocation(job, date, rule, endDate);\n  scheduleInvocation(inv);\n  return inv;\n}\n\nmodule.exports = {\n  Range: Range,\n  RecurrenceRule: RecurrenceRule,\n  Invocation: Invocation,\n  cancelInvocation: cancelInvocation,\n  scheduleInvocation: scheduleInvocation,\n  scheduleNextRecurrence: scheduleNextRecurrence,\n  sorter: sorter,\n  _invocations: invocations\n};","map":null,"metadata":{},"sourceType":"script"}