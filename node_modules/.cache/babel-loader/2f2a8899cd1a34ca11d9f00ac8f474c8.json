{"ast":null,"code":"'use strict';\n\nvar events = require('events');\n\nvar cronParser = require('cron-parser');\n\nvar CronDate = require('cron-parser/lib/date');\n\nvar sorted = require('sorted-array-functions');\n\nvar _require = require('./Invocation'),\n    scheduleNextRecurrence = _require.scheduleNextRecurrence,\n    scheduleInvocation = _require.scheduleInvocation,\n    cancelInvocation = _require.cancelInvocation,\n    RecurrenceRule = _require.RecurrenceRule,\n    sorter = _require.sorter,\n    Invocation = _require.Invocation;\n\nvar _require2 = require('./utils/dateUtils'),\n    isValidDate = _require2.isValidDate;\n\nvar scheduledJobs = {};\nvar anonJobCounter = 0;\n\nfunction resolveAnonJobName() {\n  var now = new Date();\n\n  if (anonJobCounter === Number.MAX_SAFE_INTEGER) {\n    anonJobCounter = 0;\n  }\n\n  anonJobCounter++;\n  return \"<Anonymous Job \".concat(anonJobCounter, \" \").concat(now.toISOString(), \">\");\n}\n\nfunction Job(name, job, callback) {\n  // setup a private pendingInvocations variable\n  this.pendingInvocations = []; //setup a private number of invocations variable\n\n  var triggeredJobs = 0; // Set scope vars\n\n  var jobName = name && typeof name === 'string' ? name : resolveAnonJobName();\n  this.job = name && typeof name === 'function' ? name : job; // Make sure callback is actually a callback\n\n  if (this.job === name) {\n    // Name wasn't provided and maybe a callback is there\n    this.callback = typeof job === 'function' ? job : false;\n  } else {\n    // Name was provided, and maybe a callback is there\n    this.callback = typeof callback === 'function' ? callback : false;\n  } // task count\n\n\n  this.running = 0; // Check for generator\n\n  if (typeof this.job === 'function' && this.job.prototype && this.job.prototype.next) {\n    this.job = function () {\n      return this.next().value;\n    }.bind(this.job.call(this));\n  } // define properties\n\n\n  Object.defineProperty(this, 'name', {\n    value: jobName,\n    writable: false,\n    enumerable: true\n  }); // method that require private access\n\n  this.trackInvocation = function (invocation) {\n    // add to our invocation list\n    sorted.add(this.pendingInvocations, invocation, sorter);\n    return true;\n  };\n\n  this.stopTrackingInvocation = function (invocation) {\n    var invIdx = this.pendingInvocations.indexOf(invocation);\n\n    if (invIdx > -1) {\n      this.pendingInvocations.splice(invIdx, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n  this.triggeredJobs = function () {\n    return triggeredJobs;\n  };\n\n  this.setTriggeredJobs = function (triggeredJob) {\n    triggeredJobs = triggeredJob;\n  };\n\n  this.deleteFromSchedule = function () {\n    deleteScheduledJob(this.name);\n  };\n\n  this.cancel = function (reschedule) {\n    reschedule = typeof reschedule == 'boolean' ? reschedule : false;\n    var inv, newInv;\n    var newInvs = [];\n\n    for (var j = 0; j < this.pendingInvocations.length; j++) {\n      inv = this.pendingInvocations[j];\n      cancelInvocation(inv);\n\n      if (reschedule && (inv.recurrenceRule.recurs || inv.recurrenceRule.next)) {\n        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);\n\n        if (newInv !== null) {\n          newInvs.push(newInv);\n        }\n      }\n    }\n\n    this.pendingInvocations = [];\n\n    for (var k = 0; k < newInvs.length; k++) {\n      this.trackInvocation(newInvs[k]);\n    } // remove from scheduledJobs if reschedule === false\n\n\n    if (!reschedule) {\n      this.deleteFromSchedule();\n    }\n\n    return true;\n  };\n\n  this.cancelNext = function (reschedule) {\n    reschedule = typeof reschedule == 'boolean' ? reschedule : true;\n\n    if (!this.pendingInvocations.length) {\n      return false;\n    }\n\n    var newInv;\n    var nextInv = this.pendingInvocations.shift();\n    cancelInvocation(nextInv);\n\n    if (reschedule && (nextInv.recurrenceRule.recurs || nextInv.recurrenceRule.next)) {\n      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);\n\n      if (newInv !== null) {\n        this.trackInvocation(newInv);\n      }\n    }\n\n    return true;\n  };\n\n  this.reschedule = function (spec) {\n    var inv;\n    var invocationsToCancel = this.pendingInvocations.slice();\n\n    for (var j = 0; j < invocationsToCancel.length; j++) {\n      inv = invocationsToCancel[j];\n      cancelInvocation(inv);\n    }\n\n    this.pendingInvocations = [];\n\n    if (this.schedule(spec)) {\n      this.setTriggeredJobs(0);\n      return true;\n    } else {\n      this.pendingInvocations = invocationsToCancel;\n      return false;\n    }\n  };\n\n  this.nextInvocation = function () {\n    if (!this.pendingInvocations.length) {\n      return null;\n    }\n\n    return this.pendingInvocations[0].fireDate;\n  };\n}\n\nObject.setPrototypeOf(Job.prototype, events.EventEmitter.prototype);\n\nJob.prototype.invoke = function (fireDate) {\n  this.setTriggeredJobs(this.triggeredJobs() + 1);\n  return this.job(fireDate);\n};\n\nJob.prototype.runOnDate = function (date) {\n  return this.schedule(date);\n};\n\nJob.prototype.schedule = function (spec) {\n  var self = this;\n  var success = false;\n  var inv;\n  var start;\n  var end;\n  var tz; // save passed-in value before 'spec' is replaced\n\n  if (typeof spec === 'object' && 'tz' in spec) {\n    tz = spec.tz;\n  }\n\n  if (typeof spec === 'object' && spec.rule) {\n    start = spec.start || undefined;\n    end = spec.end || undefined;\n    spec = spec.rule;\n\n    if (start) {\n      if (!(start instanceof Date)) {\n        start = new Date(start);\n      }\n\n      start = new CronDate(start, tz);\n\n      if (!isValidDate(start) || start.getTime() < Date.now()) {\n        start = undefined;\n      }\n    }\n\n    if (end && !(end instanceof Date) && !isValidDate(end = new Date(end))) {\n      end = undefined;\n    }\n\n    if (end) {\n      end = new CronDate(end, tz);\n    }\n  }\n\n  try {\n    var res = cronParser.parseExpression(spec, {\n      currentDate: start,\n      tz: tz\n    });\n    inv = scheduleNextRecurrence(res, self, start, end);\n\n    if (inv !== null) {\n      success = self.trackInvocation(inv);\n    }\n  } catch (err) {\n    var type = typeof spec;\n\n    if (type === 'string' || type === 'number') {\n      spec = new Date(spec);\n    }\n\n    if (spec instanceof Date && isValidDate(spec)) {\n      spec = new CronDate(spec);\n      self.isOneTimeJob = true;\n\n      if (spec.getTime() >= Date.now()) {\n        inv = new Invocation(self, spec);\n        scheduleInvocation(inv);\n        success = self.trackInvocation(inv);\n      }\n    } else if (type === 'object') {\n      self.isOneTimeJob = false;\n\n      if (!(spec instanceof RecurrenceRule)) {\n        var r = new RecurrenceRule();\n\n        if ('year' in spec) {\n          r.year = spec.year;\n        }\n\n        if ('month' in spec) {\n          r.month = spec.month;\n        }\n\n        if ('date' in spec) {\n          r.date = spec.date;\n        }\n\n        if ('dayOfWeek' in spec) {\n          r.dayOfWeek = spec.dayOfWeek;\n        }\n\n        if ('hour' in spec) {\n          r.hour = spec.hour;\n        }\n\n        if ('minute' in spec) {\n          r.minute = spec.minute;\n        }\n\n        if ('second' in spec) {\n          r.second = spec.second;\n        }\n\n        spec = r;\n      }\n\n      spec.tz = tz;\n      inv = scheduleNextRecurrence(spec, self, start, end);\n\n      if (inv !== null) {\n        success = self.trackInvocation(inv);\n      }\n    }\n  }\n\n  scheduledJobs[this.name] = this;\n  return success;\n};\n\nfunction deleteScheduledJob(name) {\n  if (name) {\n    delete scheduledJobs[name];\n  }\n}\n\nmodule.exports = {\n  Job: Job,\n  deleteScheduledJob: deleteScheduledJob,\n  scheduledJobs: scheduledJobs\n};","map":null,"metadata":{},"sourceType":"script"}